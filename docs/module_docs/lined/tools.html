
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>lined.tools &#8212; lined 0.1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="lined.util" href="util.html" />
    <link rel="prev" title="lined.simple" href="simple.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-lined.tools">
<span id="lined-tools"></span><h1>lined.tools<a class="headerlink" href="#module-lined.tools" title="Permalink to this headline">¶</a></h1>
<p>All kinds of useful tools to use in pipelines.</p>
<dl class="py class">
<dt id="lined.tools.BufferStats">
<em class="property">class </em><code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">BufferStats</code><span class="sig-paren">(</span><em class="sig-param">values=()</em>, <em class="sig-param">maxlen: int = &lt;object object&gt;</em>, <em class="sig-param">func: Callable = &lt;built-in function sum&gt;</em>, <em class="sig-param">add_new_val: Callable = &lt;method 'append' of 'collections.deque' objects&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#BufferStats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.BufferStats" title="Permalink to this definition">¶</a></dt>
<dd><p>A callable (fifo) buffer. Calls add input to it, but also returns some results
computed from it’s contents.</p>
<p>What “add” means is configurable (through <code class="docutils literal notranslate"><span class="pre">add_new_val</span></code> arg). Default
is append, but can be extend etc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bs</span> <span class="o">=</span> <span class="n">BufferStats</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="nb">sum</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)))</span>
<span class="go">[0, 1, 3, 6, 10, 14, 18]</span>
</pre></div>
</div>
<p>See what happens when you feed the same sequence again:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)))</span>
<span class="go">[15, 12, 9, 6, 10, 14, 18]</span>
</pre></div>
</div>
<p>More examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">BufferStats</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">),</span> <span class="s1">&#39;abcdefgh&#39;</span><span class="p">))</span>
<span class="go">[&#39;a&#39;, &#39;ab&#39;, &#39;abc&#39;, &#39;abcd&#39;, &#39;bcde&#39;, &#39;cdef&#39;, &#39;defg&#39;, &#39;efgh&#39;]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">prod</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">BufferStats</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">prod</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)))</span>
<span class="go">[0, 0, 0, 0, 24, 120, 360]</span>
</pre></div>
</div>
<p>With a different <code class="docutils literal notranslate"><span class="pre">add_new_val</span></code> choice.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bs</span> <span class="o">=</span> <span class="n">BufferStats</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">,</span> <span class="n">add_new_val</span><span class="o">=</span><span class="n">deque</span><span class="o">.</span><span class="n">appendleft</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="s1">&#39;abcdefgh&#39;</span><span class="p">))</span>
<span class="go">[&#39;a&#39;, &#39;ba&#39;, &#39;cba&#39;, &#39;dcba&#39;, &#39;edcb&#39;, &#39;fedc&#39;, &#39;gfed&#39;, &#39;hgfe&#39;]</span>
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">add_new_val=deque.extend</span></code>, data can be fed in chunks.
In the following, also see how we use iterize to get a function that
takes an iterator and returns an iterator</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lined</span> <span class="kn">import</span> <span class="n">iterize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window_stats</span> <span class="o">=</span> <span class="n">iterize</span><span class="p">(</span><span class="n">BufferStats</span><span class="p">(</span>
<span class="gp">... </span><span class="n">maxlen</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">,</span> <span class="n">add_new_val</span><span class="o">=</span><span class="n">deque</span><span class="o">.</span><span class="n">extend</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chks</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;bc&#39;</span><span class="p">,</span> <span class="s1">&#39;def&#39;</span><span class="p">,</span> <span class="s1">&#39;gh&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">window_stats</span><span class="p">(</span><span class="n">chks</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">a</span>
<span class="go">abc</span>
<span class="go">cdef</span>
<span class="go">efgh</span>
</pre></div>
</div>
<p>Note: To those who might think that they can optimize this for special
cases: Yes you can.
But SHOULD you? Is it worth the increase in complexity and reduction in
flexibility?
See <a class="reference external" href="https://github.com/thorwhalen/umpyre/blob/master/misc">https://github.com/thorwhalen/umpyre/blob/master/misc</a>
/performance_of_rolling_window_stats.md</p>
</dd></dl>

<dl class="py class">
<dt id="lined.tools.Command">
<em class="property">class </em><code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">Command</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#Command"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.Command" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a no-input callable that will execute a specific function call.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">command</span> <span class="o">=</span> <span class="n">Command</span><span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">command</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">command</span> <span class="o">=</span> <span class="n">Command</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">command</span><span class="p">()</span>
<span class="go">hello, world</span>
</pre></div>
</div>
<p>See: <a class="reference external" href="https://en.wikipedia.org/wiki/Command_pattern">https://en.wikipedia.org/wiki/Command_pattern</a></p>
</dd></dl>

<dl class="py class">
<dt id="lined.tools.DynamicIndexer">
<em class="property">class </em><code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">DynamicIndexer</code><span class="sig-paren">(</span><em class="sig-param">start_idx: Union[int, float] = 0, idx_updater: Callable[[Union[int, float], Any], Union[int, float]] = &lt;function count_increments&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#DynamicIndexer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.DynamicIndexer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>current_idx</strong> – The index to start at (the first data item will have this index)</p></li>
<li><p><strong>idx_updater</strong> – The (Index, DataItem) -&gt; Index</p></li>
</ul>
</dd>
</dl>
<p>Let’s take a finite stream of finite iterables (strings here):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stream</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;stream&#39;</span><span class="p">,</span> <span class="s1">&#39;of&#39;</span><span class="p">,</span> <span class="s1">&#39;different&#39;</span><span class="p">,</span> <span class="s1">&#39;sized&#39;</span><span class="p">,</span> <span class="s1">&#39;chunks&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The default <code class="docutils literal notranslate"><span class="pre">DynamicIndexer</span></code> just does what <code class="docutils literal notranslate"><span class="pre">enumerate</span></code> does:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">counter_index</span> <span class="o">=</span> <span class="n">DynamicIndexer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">counter_index</span><span class="p">,</span> <span class="n">stream</span><span class="p">))</span>
<span class="go">[(0, &#39;stream&#39;), (1, &#39;of&#39;), (2, &#39;different&#39;), (3, &#39;sized&#39;), (4, &#39;chunks&#39;)]</span>
</pre></div>
</div>
<p>That’s because it uses the default <code class="docutils literal notranslate"><span class="pre">idx_updater</span></code> function just increments by one.
This function, DynamicIndexer.count_increments, is shown below</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">count_increments</span><span class="p">(</span><span class="n">current_idx</span><span class="p">,</span> <span class="n">data_item</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">current_idx</span> <span class="o">+</span> <span class="n">step</span>
</pre></div>
</div>
<p>To get the index starting at 10, we can specify <code class="docutils literal notranslate"><span class="pre">start_idx=10</span></code>, and to step the
index by 3 we can partialize <code class="docutils literal notranslate"><span class="pre">count_increments</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">step3</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">count_increments</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">DynamicIndexer</span><span class="p">(</span><span class="n">start_idx</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">idx_updater</span><span class="o">=</span><span class="n">step3</span><span class="p">),</span> <span class="n">stream</span><span class="p">))</span>
<span class="go">[(10, &#39;stream&#39;), (13, &#39;of&#39;), (16, &#39;different&#39;), (19, &#39;sized&#39;), (22, &#39;chunks&#39;)]</span>
</pre></div>
</div>
<p>You can specify any custom <code class="docutils literal notranslate"><span class="pre">idx_updater</span></code> you want: The requirements being that
this function should take <code class="docutils literal notranslate"><span class="pre">(current_idx,</span> <span class="pre">data_item)</span></code> as the input, and
return the next “current index”, that is, what the index of the next data item will
be.
Note that <code class="docutils literal notranslate"><span class="pre">count_increments</span></code> ignored the <code class="docutils literal notranslate"><span class="pre">data_item</span></code> completely, but sometimes
you want to take the data item into account.
For example, your data item may contain several elements, and you want your
index to index these elements, therefore you should update your index by
incrementing it with the number of elements.</p>
<p>We have <code class="docutils literal notranslate"><span class="pre">DynamicIndexer.size_increments</span></code> for that, the code is shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">size_increments</span><span class="p">(</span><span class="n">current_idx</span><span class="p">,</span> <span class="n">data_item</span><span class="p">,</span> <span class="n">size_func</span><span class="o">=</span><span class="nb">len</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">current_idx</span> <span class="o">+</span> <span class="n">size_func</span><span class="p">(</span><span class="n">data_item</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">size_index</span> <span class="o">=</span> <span class="n">DynamicIndexer</span><span class="p">(</span><span class="n">idx_updater</span><span class="o">=</span><span class="n">DynamicIndexer</span><span class="o">.</span><span class="n">size_increments</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">size_index</span><span class="p">,</span> <span class="n">stream</span><span class="p">))</span>
<span class="go">[(0, &#39;stream&#39;), (6, &#39;of&#39;), (8, &#39;different&#39;), (17, &#39;sized&#39;), (22, &#39;chunks&#39;)]</span>
</pre></div>
</div>
<p>Q: What if I want the index of a data item to be a function of the data item itself?</p>
<p>A: Then you would use that function to make the <code class="docutils literal notranslate"><span class="pre">(idxof(data_item),</span> <span class="pre">data_item)</span></code>
pairs directly. <code class="docutils literal notranslate"><span class="pre">DynamicIndexer</span></code> is for the use case where the index of an item
depends on the (number of, sizes of, etc.) items that came before it.</p>
</dd></dl>

<dl class="py class">
<dt id="lined.tools.Enumerate">
<em class="property">class </em><code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">Enumerate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">step</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#Enumerate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.Enumerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator a function so it enumerates the number of calls.
Or in general, returns (cursor, func(x)) instead of just func(x),
where the start and step of the cursor can
be defined (default is start=0 and step=1)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_foo</span> <span class="o">=</span> <span class="n">Enumerate</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_foo</span><span class="p">(</span><span class="s1">&#39;ha&#39;</span><span class="p">)</span>
<span class="go">(0, &#39;haha&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_foo</span><span class="p">(</span><span class="s1">&#39;ho&#39;</span><span class="p">)</span>
<span class="go">(1, &#39;hoho&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum_foo_with_step</span> <span class="o">=</span> <span class="n">Enumerate</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum_foo_with_step</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="go">(3, &#39;zz&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum_foo_with_step</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="go">(10, 22)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py exception">
<dt id="lined.tools.ItemsNotSorted">
<em class="property">exception </em><code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">ItemsNotSorted</code><a class="reference internal" href="../../_modules/lined/tools.html#ItemsNotSorted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.ItemsNotSorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Use to indicate that two consecutive items where not in the expected
order</p>
</dd></dl>

<dl class="py class">
<dt id="lined.tools.Segmenter">
<em class="property">class </em><code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">Segmenter</code><span class="sig-paren">(</span><em class="sig-param">buffer: lined.tools.BufferStats, stats_buffer_callback: Callable[[Any, Iterable], Any] = &lt;function return_buffer_on_stats_condition&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#Segmenter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.Segmenter" title="Permalink to this definition">¶</a></dt>
<dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bs</span> <span class="o">=</span> <span class="n">BufferStats</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="nb">sum</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">return_if_stats_is_odd</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">return_buffer_on_stats_condition</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">else_val</span><span class="o">=</span><span class="s1">&#39;The sum is not odd!&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seg</span> <span class="o">=</span> <span class="n">Segmenter</span><span class="p">(</span><span class="n">buffer</span><span class="o">=</span><span class="n">bs</span><span class="p">,</span> <span class="n">stats_buffer_callback</span><span class="o">=</span><span class="n">return_if_stats_is_odd</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seg</span><span class="p">(</span><span class="n">new_val</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># since the sum of the values in the buffer [1] is odd, the buffer is returned</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>Adding 1 + 2 is still odd so:
&gt;&gt;&gt; seg(new_val=2)
[1, 2]</p>
<p>Now since 1 + 2 + 5 is even, the else_val of return_if_stats_is_odd is returned instead
&gt;&gt;&gt; seg(new_val=5)
‘The sum is not odd!’</p>
<dl class="py method">
<dt id="lined.tools.Segmenter.stats_buffer_callback">
<code class="sig-name descname">stats_buffer_callback</code><span class="sig-paren">(</span><em class="sig-param">buffer: Iterable</em>, <em class="sig-param">cond: Callable = &lt;function is_not_none&gt;</em>, <em class="sig-param">else_val=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lined.tools.Segmenter.stats_buffer_callback" title="Permalink to this definition">¶</a></dt>
<dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">return_buffer_on_stats_condition</span><span class="p">(</span><span class="n">stats</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">cond</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">return_buffer_on_stats_condition</span><span class="p">(</span><span class="n">stats</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">cond</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">else_val</span><span class="o">=</span><span class="s1">&#39;3 is not even!&#39;</span><span class="p">)</span>
<span class="go">&#39;3 is not even!&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="lined.tools.append_output_to_input">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">append_output_to_input</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">appender=&lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#append_output_to_input"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.append_output_to_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator that makes the function into a function returning its input with output</p>
<p>┌─────────────┐
│    input    │
└─────────────┘</p>
<blockquote>
<div><p>│
▼</p>
</div></blockquote>
<p>┌─────────────┐
│    func     │
└─────────────┘</p>
<blockquote>
<div><p>│
▼</p>
</div></blockquote>
<p>┌─────────────────┐
│ (input, output) │
└─────────────────┘</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;hello </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">)</span>
<span class="go">&#39;hello world&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_func</span> <span class="o">=</span> <span class="n">append_output_to_input</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_func</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">)</span>
<span class="go">(&#39;world&#39;, &#39;hello world&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.apply_to_single_item">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">apply_to_single_item</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span></em>, <em class="sig-param"><span class="n">item_idx</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#apply_to_single_item"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.apply_to_single_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a version of func that applies itself to only the item_idx-th
element of the input,
leaving the rest untouched.</p>
<p>That is, apply_to_single_item(func, 2), for example, is a new_func such that
<a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a></p>
<blockquote>
<div><p>new_func([a, b, c, d, e]) == [a, b, func(c), d, e]</p>
</div></blockquote>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>func</strong> – A function to apply to a single element of an iterable (that</p>
</dd>
</dl>
<p>has a […])
:param item_idx: The particular item index to apply function to
:return:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">apply_to_second_item</span> <span class="o">=</span> <span class="n">apply_to_single_item</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span> <span class="n">item_idx</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_to_second_item</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">(1, 20, 2, 3, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.blind">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">blind</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">output</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#blind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.blind" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes one argument, and returns it as is.
The output is meant to be bound by currying (functools.partial)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">true_no_matter_what</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">blind</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false_no_matter_what</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">blind</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">true_no_matter_what</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false_no_matter_what</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.cast_to_tuple_if_non_iterable_or_a_string">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">cast_to_tuple_if_non_iterable_or_a_string</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">*</em>, <em class="sig-param">if_func=&lt;function is_not_iterable_or_is_a_str&gt;</em>, <em class="sig-param">then_func=&lt;function make_it_a_tuple&gt;</em>, <em class="sig-param">else_func=&lt;function identity&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#lined.tools.cast_to_tuple_if_non_iterable_or_a_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the if-then-else logic as a function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">if_then_else</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;world&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">if_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;world&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">then_func</span><span class="o">=</span><span class="s2">&quot;hello </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">else_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;hello world&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">if_then_else</span><span class="p">(</span><span class="s1">&#39;bora&#39;</span><span class="p">,</span> <span class="n">if_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;world&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">then_func</span><span class="o">=</span><span class="s2">&quot;hello</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">else_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;borabora&#39;</span>
</pre></div>
</div>
<p>Really, it’s meant to be curried to make functional components.
For example, to make a function that ensures that a string is
encapsulated in a tuple, we could do this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">is_a_str</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">make_it_a_tuple</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">x</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_tuple_if_string</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">if_then_else</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">if_func</span><span class="o">=</span><span class="n">is_a_str</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">then_func</span><span class="o">=</span><span class="n">make_it_a_tuple</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_tuple_if_string</span><span class="p">(</span><span class="s1">&#39;a string&#39;</span><span class="p">)</span>
<span class="go">(&#39;a string&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_tuple_if_string</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">])</span>  <span class="c1"># not a string so returned as is</span>
<span class="go">[&#39;a&#39;, &#39;list&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.cast_to_tuple_if_string">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">cast_to_tuple_if_string</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">*</em>, <em class="sig-param">if_func=&lt;function is_a_str&gt;</em>, <em class="sig-param">then_func=&lt;function make_it_a_tuple&gt;</em>, <em class="sig-param">else_func=&lt;function identity&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#lined.tools.cast_to_tuple_if_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the if-then-else logic as a function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">if_then_else</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;world&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">if_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;world&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">then_func</span><span class="o">=</span><span class="s2">&quot;hello </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">else_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;hello world&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">if_then_else</span><span class="p">(</span><span class="s1">&#39;bora&#39;</span><span class="p">,</span> <span class="n">if_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;world&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">then_func</span><span class="o">=</span><span class="s2">&quot;hello</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">else_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;borabora&#39;</span>
</pre></div>
</div>
<p>Really, it’s meant to be curried to make functional components.
For example, to make a function that ensures that a string is
encapsulated in a tuple, we could do this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">is_a_str</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">make_it_a_tuple</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">x</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_tuple_if_string</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">if_then_else</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">if_func</span><span class="o">=</span><span class="n">is_a_str</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">then_func</span><span class="o">=</span><span class="n">make_it_a_tuple</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_tuple_if_string</span><span class="p">(</span><span class="s1">&#39;a string&#39;</span><span class="p">)</span>
<span class="go">(&#39;a string&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_tuple_if_string</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">])</span>  <span class="c1"># not a string so returned as is</span>
<span class="go">[&#39;a&#39;, &#39;list&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.check_sorted_during_iteration">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">check_sorted_during_iteration</code><span class="sig-paren">(</span><em class="sig-param">iterable: Iterable, key: Callable[[Any, Any], bool] = &lt;built-in function le&gt;, not_sorted_callback: Union[Callable, BaseException] = &lt;lined.tools.Command object&gt;</em><span class="sig-paren">)</span> &#x2192; Generator<a class="reference internal" href="../../_modules/lined/tools.html#check_sorted_during_iteration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.check_sorted_during_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap an iterable so that ordering of the elements is checked at runtime.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterable</strong> – Iterable to consume</p></li>
<li><p><strong>key</strong> – The function that defines what it means to be sorted.
Could be a Any-&gt;bool function, which will act like the key argument
of builtin sorted for example.
Could also be an explicit (element, next_element)-&gt;bool function that
returns True iff in the right order</p></li>
<li><p><strong>not_sorted_callback</strong> – The function to call when two consecutive</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>elements are not sorted. For example:</dt><dd><ul class="simple">
<li><p>raising an error (the default)</p></li>
<li><p>logging the information, and skiping the offending element (or not)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A generator consuming the input iterable</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">check_sorted_during_iteration</span><span class="p">(</span><span class="nb">iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])))</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">check_sorted_during_iteration</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]),</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="n">ItemsNotSorted</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span>
<span class="gp">... </span>        <span class="sa">f</span><span class="s2">&quot;ItemsNotSorted after </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> element (whose value was </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span>
<span class="gp">... </span>        <span class="s2">&quot;----&gt; Normally, here, you&#39;d put exception handling code&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">2</span>
<span class="go">4</span>
<span class="go">ItemsNotSorted after 2 element (whose value was 4)</span>
<span class="go">----&gt; Normally, here, you&#39;d put exception handling code</span>
</pre></div>
</div>
<p>Now, mind you, you have total control over what sorted means.
For example, to define it as strict</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">comp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>  <span class="c1"># in real life, use operator.gt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">check_sorted_during_iteration</span><span class="p">(</span><span class="nb">iter</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">key</span><span class="o">=</span><span class="n">comp</span><span class="p">))</span>
<span class="go">[4, 3, 2, 1]</span>
</pre></div>
</div>
<p>Now for a more complex example.
First we’ll define a function that will consume the iterable until an
error occurs, returning the elements consumed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lined.tools</span> <span class="kn">import</span> <span class="n">consume_until_error</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lined.simple</span> <span class="kn">import</span> <span class="n">Pipe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consume</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">check_sorted_during_iteration</span><span class="p">,</span> <span class="n">consume_until_error</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iterable</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;ba&#39;</span><span class="p">,</span> <span class="s1">&#39;cba&#39;</span><span class="p">,</span> <span class="s1">&#39;cba&#39;</span><span class="p">,</span> <span class="s1">&#39;back&#39;</span><span class="p">,</span> <span class="s1">&#39;bacca&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consume</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># compare with strict &lt;</span>
<span class="go">[&#39;a&#39;, &#39;ba&#39;, &#39;cba&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consume</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="nb">len</span><span class="p">)</span>  <span class="c1"># compare based on the length</span>
<span class="go">[&#39;a&#39;, &#39;ba&#39;, &#39;cba&#39;, &#39;cba&#39;, &#39;back&#39;, &#39;bacca&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consume</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># compare based on first letter only</span>
<span class="go">[&#39;a&#39;, &#39;ba&#39;, &#39;cba&#39;, &#39;cba&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># compare based on whether the previous element is a subset of the next:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consume</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="go">[&#39;a&#39;, &#39;ba&#39;, &#39;cba&#39;, &#39;cba&#39;, &#39;back&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.consume_until_error">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">consume_until_error</code><span class="sig-paren">(</span><em class="sig-param">iterable</em>, <em class="sig-param">caught_errors=(&lt;class 'Exception'&gt;</em>, <em class="sig-param">)</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#consume_until_error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.consume_until_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterable that will simply exit with out error if one of the caught
errors occurs.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">consume_until_error</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
<span class="go">[0.25, 0.5, 1.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.deiterize">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">deiterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#deiterize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.deiterize" title="Permalink to this definition">¶</a></dt>
<dd><p>The inverse of iterize.
Takes an “iterized” (a.k.a. “vectorized”) function (i.e. a function that
works on iterables), and
That is, takes a func(X,…) function and returns a next(iter(func([X],
…))) function.</p>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.del_fields">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">del_fields</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">fields</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#del_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.del_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the same mapping, but with specified fields removed.
Intended to be applied to a stream of Mappings, using partial to fix fields</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">del_fields</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]),</span> <span class="n">d</span><span class="p">))</span>
<span class="go">[{&#39;b&#39;: 2}, {&#39;c&#39;: 3}]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.enumerate_groups">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">enumerate_groups</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">iterable</span></em>, <em class="sig-param"><span class="n">key</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#enumerate_groups"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.enumerate_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Get enumeration of groups during a groupby call.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterable</strong> – An iterable</p></li>
<li><p><strong>key</strong> – The key to use in the groupby logic</p></li>
<li><p><strong>start</strong> – Where to start the enumeration (default is 0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A generator of (group_idx, group, item) triples</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iterable</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">enumerate_groups</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span>
<span class="gp">... </span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">... </span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">... </span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">... </span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
<span class="gp">... </span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
<span class="gp">... </span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
<span class="gp">... </span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">... </span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">... </span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
<span class="gp">... </span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="gp">... </span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span> <span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.expanded_args">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">expanded_args</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#expanded_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.expanded_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Make’s a func(<a href="#id9"><span class="problematic" id="id10">*</span></a>args) function out of a func(args) one.
In a way, the opposite of map_star.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mysum</span> <span class="o">=</span> <span class="n">expanded_args</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mysum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.false_no_matter_what">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">false_no_matter_what</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">output</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#lined.tools.false_no_matter_what" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes one argument, and returns it as is.
The output is meant to be bound by currying (functools.partial)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">true_no_matter_what</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">blind</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false_no_matter_what</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">blind</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">true_no_matter_what</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false_no_matter_what</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.generator_version">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">generator_version</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#lined.tools.generator_version" title="Permalink to this definition">¶</a></dt>
<dd><p>From an Input-&gt;Ouput function, makes a Iterator[Input]-&gt;Itertor[Output]
Some call this “vectorization”, but it’s not really a vector, but an
iterable, thus the name.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterized_f</span> <span class="o">=</span> <span class="n">iterize</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">iterized_f</span><span class="p">(</span><span class="nb">iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])))</span>
<span class="go">[10, 20, 30]</span>
</pre></div>
</div>
<p>Consider the following pipeline:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lined</span> <span class="kn">import</span> <span class="n">Pipe</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pipe</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;hello </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pipe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;hello 2&#39;</span>
</pre></div>
</div>
<p>But what if you wanted to use the pipeline on a “stream” of data. The
following wouldn’t work:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">pipe</span><span class="p">(</span><span class="nb">iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="go">TypeError: unsupported operand type(s) for *: &#39;list_iterator&#39; and &#39;int&#39;</span>
</pre></div>
</div>
<p>Remember that error: You’ll surely encounter it at some point.</p>
<p>The solution to it is (often): <code class="docutils literal notranslate"><span class="pre">iterize</span></code>,
which transforms a function that is meant to be applied to a single object,
into a function that is meant to be applied to an array, or any iterable
of such objects.
(You might be familiar (if you use <cite>numpy</cite> for example) with the related
concept of “vectorization”,
or [array programming](<a class="reference external" href="https://en.wikipedia.org/wiki/Array_programming">https://en.wikipedia.org/wiki/Array_programming</a>).)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lined</span> <span class="kn">import</span> <span class="n">Pipe</span><span class="p">,</span> <span class="n">iterize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pipe</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">iterize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span>                <span class="n">iterize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;hello </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterable</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># see that the result is an iterable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>  <span class="c1"># consume the iterable and gather it&#39;s items</span>
<span class="go">[&#39;hello 2&#39;, &#39;hello 4&#39;, &#39;hello 6&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.identity">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">identity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes one argument, and returns it as is</p>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.if_then_else">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">if_then_else</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">if_func=functools.partial(&lt;function blind&gt;</em>, <em class="sig-param">output=True)</em>, <em class="sig-param">then_func=&lt;function identity&gt;</em>, <em class="sig-param">else_func=&lt;function identity&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#if_then_else"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.if_then_else" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the if-then-else logic as a function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">if_then_else</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;world&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">if_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;world&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">then_func</span><span class="o">=</span><span class="s2">&quot;hello </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">else_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;hello world&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">if_then_else</span><span class="p">(</span><span class="s1">&#39;bora&#39;</span><span class="p">,</span> <span class="n">if_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;world&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">then_func</span><span class="o">=</span><span class="s2">&quot;hello</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">else_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;borabora&#39;</span>
</pre></div>
</div>
<p>Really, it’s meant to be curried to make functional components.
For example, to make a function that ensures that a string is
encapsulated in a tuple, we could do this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">is_a_str</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">make_it_a_tuple</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">x</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_tuple_if_string</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">if_then_else</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">if_func</span><span class="o">=</span><span class="n">is_a_str</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">then_func</span><span class="o">=</span><span class="n">make_it_a_tuple</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_tuple_if_string</span><span class="p">(</span><span class="s1">&#39;a string&#39;</span><span class="p">)</span>
<span class="go">(&#39;a string&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_tuple_if_string</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">])</span>  <span class="c1"># not a string so returned as is</span>
<span class="go">[&#39;a&#39;, &#39;list&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.items">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">items</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapping</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#items"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an items generator from a mapping</p>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.iterate">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">iterate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">iterable</span><span class="p">:</span> <span class="n">Iterable</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#iterate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.iterate" title="Permalink to this definition">¶</a></dt>
<dd><p>Just iterate through a iterable
Use this to “consume” or “run” an iterator automatically.</p>
<p>For example, consider the following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lined</span> <span class="kn">import</span> <span class="n">Pipe</span><span class="p">,</span> <span class="n">iterize</span><span class="p">,</span> <span class="n">iterate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pipe</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">iterize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">iterize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;hello </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">pipe</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="go">hello 2</span>
<span class="go">hello 4</span>
<span class="go">hello 6</span>
</pre></div>
</div>
<p>It could be a bit awkward to have to “consume” the iterable to have it
take effect.
Just calling  <code class="docutils literal notranslate"><span class="pre">pipe([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code> to get those prints seems like a more
natural way.
This is where you can use <cite>iterate</cite>. It basically “launches” that
consuming loop for you.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pipe</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">iterize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">iterize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;hello </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="n">iterate</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pipe</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">hello 2</span>
<span class="go">hello 4</span>
<span class="go">hello 6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.iterize">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">iterize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#iterize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.iterize" title="Permalink to this definition">¶</a></dt>
<dd><p>From an Input-&gt;Ouput function, makes a Iterator[Input]-&gt;Itertor[Output]
Some call this “vectorization”, but it’s not really a vector, but an
iterable, thus the name.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterized_f</span> <span class="o">=</span> <span class="n">iterize</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">iterized_f</span><span class="p">(</span><span class="nb">iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])))</span>
<span class="go">[10, 20, 30]</span>
</pre></div>
</div>
<p>Consider the following pipeline:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lined</span> <span class="kn">import</span> <span class="n">Pipe</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pipe</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;hello </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pipe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;hello 2&#39;</span>
</pre></div>
</div>
<p>But what if you wanted to use the pipeline on a “stream” of data. The
following wouldn’t work:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">pipe</span><span class="p">(</span><span class="nb">iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="go">TypeError: unsupported operand type(s) for *: &#39;list_iterator&#39; and &#39;int&#39;</span>
</pre></div>
</div>
<p>Remember that error: You’ll surely encounter it at some point.</p>
<p>The solution to it is (often): <code class="docutils literal notranslate"><span class="pre">iterize</span></code>,
which transforms a function that is meant to be applied to a single object,
into a function that is meant to be applied to an array, or any iterable
of such objects.
(You might be familiar (if you use <cite>numpy</cite> for example) with the related
concept of “vectorization”,
or [array programming](<a class="reference external" href="https://en.wikipedia.org/wiki/Array_programming">https://en.wikipedia.org/wiki/Array_programming</a>).)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lined</span> <span class="kn">import</span> <span class="n">Pipe</span><span class="p">,</span> <span class="n">iterize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pipe</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">iterize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span>                <span class="n">iterize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;hello </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterable</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># see that the result is an iterable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>  <span class="c1"># consume the iterable and gather it&#39;s items</span>
<span class="go">[&#39;hello 2&#39;, &#39;hello 4&#39;, &#39;hello 6&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.keys_extractor">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">keys_extractor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">keys</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#keys_extractor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.keys_extractor" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use operator.itemgetter(<a href="#id11"><span class="problematic" id="id12">*</span></a>keys) instead.</p>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.map_star">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">map_star</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#map_star"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.map_star" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a func(args) function out of a func(<a href="#id13"><span class="problematic" id="id14">*</span></a>args) o.
Also known as singularize_arg_input.
In a way, the opposite of map_starexpanded_args.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">singularized_foo</span> <span class="o">=</span> <span class="n">map_star</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">singularized_foo</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">singularized_foo</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="n">singularized_foo</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span> <span class="o">==</span> <span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.negate">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">negate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#negate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.negate" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a negated version of a function</p>
<p>Will return a function with
the same signature, but whose output is negated (that is, it calls the original
function getting the <cite>output</cite> but instead of returning it,
it returns <cite>not output</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sum_is_zero</span> <span class="o">=</span> <span class="n">negate</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sum_is_zero</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sum_is_zero</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.pairwise">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">pairwise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">iterable</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#pairwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield sliding window pairs</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">pairwise</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="go">[(1, 2), (2, 3), (3, 4)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.print_and_pass_on">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">print_and_pass_on</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">*</em>, <em class="sig-param">callback=&lt;built-in function print&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#lined.tools.print_and_pass_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Passes input through to output, but prints before outputing</p>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.raise_">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">raise_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">exception</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#raise_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.raise_" title="Permalink to this definition">¶</a></dt>
<dd><p>raises the given exception (instance or callable that returns one)
Meant to be hooked to the out put of a function that returns an exception or a
command to raise one.</p>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.raise_exception">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">raise_exception</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">exception</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Callable<span class="p">, </span>BaseException<span class="p">]</span></span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#raise_exception"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.raise_exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise an exception (from an exception instance, or a callable that
makes one</p>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.return_buffer_on_stats_condition">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">return_buffer_on_stats_condition</code><span class="sig-paren">(</span><em class="sig-param">stats: Any</em>, <em class="sig-param">buffer: Iterable</em>, <em class="sig-param">cond: Callable = &lt;function is_not_none&gt;</em>, <em class="sig-param">else_val=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#return_buffer_on_stats_condition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.return_buffer_on_stats_condition" title="Permalink to this definition">¶</a></dt>
<dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">return_buffer_on_stats_condition</span><span class="p">(</span><span class="n">stats</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">cond</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">return_buffer_on_stats_condition</span><span class="p">(</span><span class="n">stats</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">cond</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">else_val</span><span class="o">=</span><span class="s1">&#39;3 is not even!&#39;</span><span class="p">)</span>
<span class="go">&#39;3 is not even!&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.return_instead_of_raising_exceptions">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">return_instead_of_raising_exceptions</code><span class="sig-paren">(</span><em class="sig-param">func=None</em>, <em class="sig-param">*</em>, <em class="sig-param">exceptions=(&lt;class 'Exception'&gt;</em>, <em class="sig-param">)</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#return_instead_of_raising_exceptions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.return_instead_of_raising_exceptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a function return its exceptions instead of raising them.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">return_instead_of_raising_exceptions</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># note that this doesn&#39;t raise, but returns the exception (instance)</span>
<span class="go">ZeroDivisionError(&#39;division by zero&#39;)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – The function to transform.</p></li>
<li><p><strong>exceptions</strong> – The exceptions to handle
Default is Exception (letting other BaseException instances like
KeyboardInterrupt still be raised). If you need more exceptions, or less
exceptions to be handled, enter them here.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.side_call">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">side_call</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">callback</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#side_call"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.side_call" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity function that calls a callaback function before returning the
input as is (unless the input is mutable and the callback changes it).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lined</span> <span class="kn">import</span> <span class="n">Pipe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add2</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logger</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">side_call</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input is </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logged_add2</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="n">add2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logged_add2</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
<span class="go">input is 40</span>
<span class="go">42</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.singularize_arg_input">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">singularize_arg_input</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="headerlink" href="#lined.tools.singularize_arg_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a func(args) function out of a func(<a href="#id15"><span class="problematic" id="id16">*</span></a>args) o.
Also known as singularize_arg_input.
In a way, the opposite of map_starexpanded_args.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">singularized_foo</span> <span class="o">=</span> <span class="n">map_star</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">singularized_foo</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">singularized_foo</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="n">singularized_foo</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span> <span class="o">==</span> <span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.tail_io">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">tail_io</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#tail_io"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.tail_io" title="Permalink to this definition">¶</a></dt>
<dd><p>Will apply function only to the tail of tuple inputs, still passing
the header on.
That is, from a <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">func(x)</span></code> function, you get a <code class="docutils literal notranslate"><span class="pre">(*header,</span> <span class="pre">x)</span> <span class="pre">-&gt;</span> <span class="pre">(</span>
<span class="pre">*header,</span> <span class="pre">func(x))</span></code> function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">(</span><span class="s1">&#39;boo&#39;</span><span class="p">)</span>
<span class="go">&#39;booboo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_foo</span> <span class="o">=</span> <span class="n">tail_io</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_foo</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;boo&#39;</span><span class="p">))</span>
<span class="go">(7, &#39;booboo&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_foo</span><span class="p">((</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;items&#39;</span><span class="p">,</span> <span class="s1">&#39;but&#39;</span><span class="p">,</span> <span class="s1">&#39;the&#39;</span><span class="p">,</span> <span class="s1">&#39;last&#39;</span><span class="p">,</span> <span class="s1">&#39;are&#39;</span><span class="p">,</span> <span class="s1">&#39;just&#39;</span><span class="p">,</span>
<span class="gp">... </span>         <span class="s1">&#39;passed&#39;</span><span class="p">,</span> <span class="s1">&#39;on&#39;</span><span class="p">,</span> <span class="s1">&#39;boo&#39;</span><span class="p">))</span>
<span class="go">(&#39;all&#39;, &#39;items&#39;, &#39;but&#39;, &#39;the&#39;, &#39;last&#39;, &#39;are&#39;, &#39;just&#39;, &#39;passed&#39;, &#39;on&#39;, &#39;booboo&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.true_no_matter_what">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">true_no_matter_what</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">output</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#lined.tools.true_no_matter_what" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes one argument, and returns it as is.
The output is meant to be bound by currying (functools.partial)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">true_no_matter_what</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">blind</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false_no_matter_what</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">blind</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">true_no_matter_what</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false_no_matter_what</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.with_cursor">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">with_cursor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">step</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#with_cursor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.with_cursor" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator a function so it enumerates the number of calls.
Or in general, returns (cursor, func(x)) instead of just func(x),
where the start and step of the cursor can
be defined (default is start=0 and step=1)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_foo</span> <span class="o">=</span> <span class="n">with_cursor</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_foo</span><span class="p">(</span><span class="s1">&#39;ha&#39;</span><span class="p">)</span>
<span class="go">(0, &#39;haha&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_foo</span><span class="p">(</span><span class="s1">&#39;ho&#39;</span><span class="p">)</span>
<span class="go">(1, &#39;hoho&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum_foo_with_step</span> <span class="o">=</span> <span class="n">with_cursor</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum_foo_with_step</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="go">(3, &#39;zz&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enum_foo_with_step</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="go">(10, 22)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="lined.tools.wrap_first_arg_in_list">
<code class="sig-prename descclassname">lined.tools.</code><code class="sig-name descname">wrap_first_arg_in_list</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/lined/tools.html#wrap_first_arg_in_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lined.tools.wrap_first_arg_in_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a func(X,…) function and returns a func([X],…) function.</p>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">lined</a></h1>








<h3>Navigation</h3>
<p><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../lined.html">lined</a></li>
<li class="toctree-l1"><a class="reference internal" href="base.html">lined.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">lined.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="recipes.html">lined.recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="simple.html">lined.simple</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">lined.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="util.html">lined.util</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="simple.html" title="previous chapter">lined.simple</a></li>
      <li>Next: <a href="util.html" title="next chapter">lined.util</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;NO COPYRIGHT.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/module_docs/lined/tools.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>