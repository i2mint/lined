<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>lined.base &mdash; lined 0.1.24 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            lined
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/lined.html">lined</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/lined/base.html">lined.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/lined/examples.html">lined.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/lined/recipes.html">lined.recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/lined/simple.html">lined.simple</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/lined/tests/test_base.html">lined.tests.test_base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/lined/tools.html">lined.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/lined/util.html">lined.util</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">lined</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">lined.base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for lined.base</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The base objects of lined.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span><span class="p">,</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">starmap</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DFLT_DEFAULT_CONFLICT_METHOD</span><span class="p">,</span>
    <span class="n">Sig</span><span class="p">,</span>
    <span class="n">call_forgivingly</span><span class="p">,</span>
    <span class="n">ch_signature_to_all_pk</span><span class="p">,</span>
    <span class="n">tuple_the_args</span><span class="p">,</span>
    <span class="n">PO</span><span class="p">,</span>  <span class="c1"># POSITION_ONLY,</span>
    <span class="n">KO</span><span class="p">,</span>  <span class="c1"># KEYWORD_ONLY</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">lined.util</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">signature_from_first_and_last_func</span><span class="p">,</span>
    <span class="n">func_name</span><span class="p">,</span>
    <span class="n">name_to_id</span><span class="p">,</span>
    <span class="n">ensure_numerical_keys</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># MultiFuncSpec = Dict[str, Callable]</span>
<span class="n">Funcs</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Callable</span><span class="p">],</span> <span class="n">Callable</span><span class="p">]</span>
<span class="n">LayeredFuncs</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Funcs</span><span class="p">]</span>


<span class="c1"># def fnode(func, name=None):</span>
<span class="c1">#     @wraps(func)</span>
<span class="c1">#     def func_node(*args, **kwargs):</span>
<span class="c1">#         return func(*args, **kwargs)</span>
<span class="c1">#</span>
<span class="c1">#     func_node.__name__ = name or func_name(func)</span>
<span class="c1">#     return func_node</span>


<div class="viewcode-block" id="Fnode"><a class="viewcode-back" href="../../module_docs/lined/base.html#lined.base.Fnode">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Fnode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A function wrapper to be used in pipelines.</span>

<span class="sd">    &gt;&gt;&gt; import pickle</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; Sig(pickle.dumps)</span>
<span class="sd">    &lt;Sig (obj, protocol=None, *, fix_imports=True, buffer_callback=None)&gt;</span>
<span class="sd">    &gt;&gt;&gt; fn = Fnode(pickle.dumps)</span>
<span class="sd">    &gt;&gt;&gt; Sig(fn)</span>
<span class="sd">    &lt;Sig (obj, protocol=None, *, fix_imports=True, buffer_callback=None)&gt;</span>

<span class="sd">    The `first_arg_position_only=True` flag will set the first argument of the</span>
<span class="sd">    Fnode instance signature to be POSITION_ONLY.</span>
<span class="sd">    This is a useful normalization for inner nodes of a pipeline.</span>

<span class="sd">    &gt;&gt;&gt; fn = Fnode(pickle.dumps, name=&#39;my_pickler&#39;, first_arg_position_only=True)</span>
<span class="sd">    &gt;&gt;&gt; Sig(fn)</span>
<span class="sd">    &lt;Sig (obj, /, protocol=None, *, fix_imports=True, buffer_callback=None)&gt;</span>
<span class="sd">    &gt;&gt;&gt; unpickled_fn = pickle.loads(pickle.dumps(fn))</span>

<span class="sd">    &gt;&gt;&gt; unpickled_fn</span>
<span class="sd">    my_pickler(obj, /, protocol=None, *, fix_imports=True, buffer_callback=None)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">first_arg_position_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="n">func_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">wraps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_arg_position_only</span><span class="p">:</span>
            <span class="n">_mk_first_argument_position_only</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}{</span><span class="n">Sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">first_arg_position_only</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">first_arg_position_only</span><span class="p">,</span>
            <span class="vm">__name__</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">__signature__</span><span class="o">=</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">state</span></div>


<span class="k">def</span> <span class="nf">fnode</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">first_arg_position_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Fnode</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">first_arg_position_only</span><span class="o">=</span><span class="n">first_arg_position_only</span><span class="p">)</span>


<span class="n">_line_init_reserved_names</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;pipeline_name&quot;</span><span class="p">,</span> <span class="s2">&quot;input_name&quot;</span><span class="p">,</span> <span class="s2">&quot;output_name&quot;</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">_func_to_name_func_pair</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From a function func, returns a pair (name_of_func, func) where name_of_func is either the existing string</span>
<span class="sd">    func.__name__ or an inferred string using func_name. If func is instead already a pair, a check is performed</span>
<span class="sd">    to ensure that it is of the expected form, i.e., in a (str, callable) form</span>

<span class="sd">    :param func: callable or a pair, in the latter case a check is performed</span>
<span class="sd">    :return: (str, callable) pair, where the string is the name of the function</span>

<span class="sd">    &gt;&gt;&gt; def my_func(x):</span>
<span class="sd">    ...    return x + 1</span>
<span class="sd">    &gt;&gt;&gt; assert _func_to_name_func_pair(my_func)[0] == &#39;my_func&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert _func_to_name_func_pair(my_func)[1] is my_func</span>

<span class="sd">    A function with no .__name__ attribute, such as a lambda, will be given a unique name automatically in the form of</span>
<span class="sd">    f&#39;unnamed_func_{i}&#39;. The uniqueness is achieved by incrementing i.</span>

<span class="sd">    &gt;&gt;&gt; my_lambda_func = lambda x: 2 * x</span>
<span class="sd">    &gt;&gt;&gt; given_name, func = _func_to_name_func_pair(my_lambda_func)</span>
<span class="sd">    &gt;&gt;&gt; assert given_name.startswith(&#39;unnamed_func_&#39;)</span>

<span class="sd">    &gt;&gt;&gt; class my_class:</span>
<span class="sd">    ...    def my_class_method(self, x):</span>
<span class="sd">    ...        return x + 2 * x</span>
<span class="sd">    &gt;&gt;&gt; assert _func_to_name_func_pair(my_class.my_class_method)[0] == &#39;my_class_method&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># We could just return func here, but to be clear...</span>
        <span class="c1"># func is actually a name func pair, so let&#39;s extract the name and the func</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="c1"># and assert these are in fact a name and a function</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span>  <span class="c1"># an finally returning it</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func_name</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">func</span>


<span class="k">def</span> <span class="nf">_merge_funcs_and_named_funcs</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">named_funcs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add the funcs of named_funcs to funcs tuple and visa versa,</span>
<span class="sd">    making two aligned collections of functions.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">_line_init_reserved_names</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">named_funcs</span><span class="p">),</span> <span class="p">(</span>
        <span class="s2">&quot;Can&#39;t name a function with any of the following strings: &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_line_init_reserved_names</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="n">funcs_obtained_from_named_funcs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">named_funcs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">named_funcs_obtained_from_funcs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">_func_to_name_func_pair</span><span class="p">,</span> <span class="n">funcs</span><span class="p">)</span>
    <span class="c1"># make sure the names are unique, by adding a suffix to some of the repeating names if necessary</span>
    <span class="n">named_funcs_obtained_from_funcs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">uniquize_funcs_names</span><span class="p">(</span><span class="n">named_funcs_obtained_from_funcs</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">assert</span> <span class="n">named_funcs_obtained_from_funcs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span>
        <span class="n">named_funcs</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Some names clashed: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">named_funcs_obtained_from_funcs</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">named_funcs</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">funcs</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">tuple</span><span class="p">(</span><span class="n">named_funcs_obtained_from_funcs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="o">+</span> <span class="n">funcs_obtained_from_named_funcs</span>
    <span class="p">)</span>

    <span class="n">named_funcs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">named_funcs_obtained_from_funcs</span><span class="p">,</span> <span class="o">**</span><span class="n">named_funcs</span><span class="p">)</span>
    <span class="c1"># print(named_funcs.values())</span>
    <span class="c1"># print(funcs)</span>
    <span class="c1"># assert set(named_funcs.values()) == set(funcs), &quot;Some of the functions have the same name,&quot; \</span>
    <span class="c1">#                                             &quot; please explicitly provide disjoint names&quot;</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">funcs</span><span class="p">,</span>
        <span class="n">named_funcs</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="uniquize_funcs_names"><a class="viewcode-back" href="../../module_docs/lined/base.html#lined.base.uniquize_funcs_names">[docs]</a><span class="k">def</span> <span class="nf">uniquize_funcs_names</span><span class="p">(</span><span class="n">named_funcs_obtained_from_funcs</span><span class="p">,</span> <span class="n">suffic_counter_start</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check and make sure that the functions names are all different. This is achieved by adding a suffix to</span>
<span class="sd">    the duplicate names</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_func_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">prefix_counter</span> <span class="o">=</span> <span class="n">suffic_counter_start</span>
    <span class="n">unique_named_funcs_obtained_from_funcs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">func_name_pair</span> <span class="ow">in</span> <span class="n">named_funcs_obtained_from_funcs</span><span class="p">:</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="n">func_name_pair</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">all_func_names</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">prefix_counter</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">prefix_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">all_func_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">unique_named_funcs_obtained_from_funcs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">unique_named_funcs_obtained_from_funcs</span></div>


<span class="k">def</span> <span class="nf">_mk_first_argument_position_only</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Replaces the first argument&#39;s parameter kind by PO (POSITION_ONLY).</span>
<span class="sd">    This is needed in some edge cases that involved functions that work only with PO</span>
<span class="sd">    kinds.</span>

<span class="sd">    &gt;&gt;&gt; str(Sig(_mk_first_argument_position_only(lambda x, y: None)))</span>
<span class="sd">    &#39;(x, /, y)&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">first_argname</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">sig</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">first_argname</span><span class="p">:</span>  <span class="c1"># if there are any arguments</span>
        <span class="n">new_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="o">.</span><span class="n">from_objs</span><span class="p">(</span>
            <span class="n">sig</span><span class="o">.</span><span class="n">modified</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">first_argname</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="n">PO</span><span class="p">}}),</span>
            <span class="n">return_annotation</span><span class="o">=</span><span class="n">sig</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">new_sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span>


<span class="k">def</span> <span class="nf">_normalize_funcs_and_named_funcs</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">named_funcs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalizing functions so we know what to expect.</span>
<span class="sd">    It&#39;s assumed that named_funcs is an iterable of names -- but in most cases</span>
<span class="sd">    should be a {name: func,...} dict aligned with funcs.</span>
<span class="sd">    What will be done here:</span>
<span class="sd">    - Wrap all funcs in an fnode instance</span>
<span class="sd">    - Make all but first function have their first argument be position only</span>

<span class="sd">    :return Transformed funcs, named_funcs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Why do we even want to set first_arg_position_only=True?</span>
    <span class="c1"># Because a Line doesn&#39;t NEED the keyword argument, and not having breaks somethings</span>
    <span class="c1"># like iterize. TODO: A better solution would be welcome</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">funcs</span><span class="p">):</span>
        <span class="c1"># make the arguments we&#39;ll call fnode on.</span>
        <span class="n">fnode_kwargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">first_arg_position_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">named_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="c1"># Override the first fnode to NOT use the first_arg_position_only flag</span>
        <span class="k">if</span> <span class="n">fnode_kwargs</span><span class="p">:</span>
            <span class="n">fnode_kwargs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;first_arg_position_only&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># make fncdes from the funcs</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fnodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fnode</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="n">fnode_kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">add_to_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;You can consider using Pipe instead of Line. Pipe doesn&#39;t have as &quot;</span>
                <span class="s2">&quot;many goodies as Line, but it&#39;s also more lenient with functions.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">add_to_msg</span><span class="p">)</span>

        <span class="n">fnodes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fnodes</span><span class="p">)</span>
        <span class="n">named_funcs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">fnode_</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">fnode_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">named_funcs</span><span class="p">,</span> <span class="n">fnodes</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">fnodes</span><span class="p">,</span> <span class="n">named_funcs</span>


<span class="n">ParamToLabel</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Parameter</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">name_with_varkind_and_default_marker</span><span class="p">:</span> <span class="n">ParamToLabel</span>


<div class="viewcode-block" id="name_with_varkind_and_default_marker"><a class="viewcode-back" href="../../module_docs/lined/base.html#lined.base.name_with_varkind_and_default_marker">[docs]</a><span class="k">def</span> <span class="nf">name_with_varkind_and_default_marker</span><span class="p">(</span><span class="n">param</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a string representation for the Parameter object&quot;&quot;&quot;</span>
    <span class="n">empty</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>

    <span class="k">def</span> <span class="nf">kind_marker</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;*&quot;</span>
        <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;**&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">kind_marker</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
        <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="p">)</span></div>


<span class="c1"># TODO: Deprecate of named_funcs? Use (name, func) mechanism only?</span>
<span class="c1"># TODO: add validation option (e.g. all downstream functions single-argumented)</span>
<span class="c1"># TODO: Handle names with spaces</span>
<span class="c1"># TODO: Better default naming (line_001, line_002, etc.?)</span>
<span class="k">class</span> <span class="nc">Line</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">funcs</span><span class="p">:</span> <span class="n">Funcs</span><span class="p">,</span>
        <span class="n">pipeline_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">input_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">output_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="c1"># **named_funcs,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs function composition.</span>
<span class="sd">        That is, get a callable that is equivalent to a chain of callables.</span>
<span class="sd">        For example, if `f`, `h`, and `g` are three functions, the function</span>

<span class="sd">        .. code-block::</span>
<span class="sd">            c = Compose(f, h, g)</span>

<span class="sd">        is such that, for any valid inputs `args, kwargs` of `f`,</span>

<span class="sd">        .. code-block::</span>
<span class="sd">        c(*args, **kwargs) == g(h(f(*args, **kwargs)))</span>

<span class="sd">        (assuming the functions are deterministic of course).</span>

<span class="sd">        :param funcs: The functions of the pipeline</span>
<span class="sd">        :param pipeline_name: The name of the pipeline</span>
<span class="sd">        :param input_name: The name of an input</span>
<span class="sd">        :param output_name: The name of an output</span>
<span class="sd">        A really simple example:</span>

<span class="sd">        &gt;&gt;&gt; p = Line(sum, str)</span>
<span class="sd">        &gt;&gt;&gt; p([2, 3])</span>
<span class="sd">        &#39;5&#39;</span>

<span class="sd">        A still quite simple example:</span>

<span class="sd">        &gt;&gt;&gt; def first(a, b=1):</span>
<span class="sd">        ...     return a * b</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; def last(c) -&gt; float:</span>
<span class="sd">        ...     return c + 10</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; f = Line(first, last)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; assert f(2) == 12</span>
<span class="sd">        &gt;&gt;&gt; assert f(2, 10) == 30</span>

<span class="sd">        Let&#39;s check out the signature of f.</span>

<span class="sd">        &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">        &gt;&gt;&gt; print(str(signature(f)))</span>
<span class="sd">        (a, b=1) -&gt; float</span>

<span class="sd">        Note that the arguments of the line (composition) are the arguments of the first</span>
<span class="sd">        function...</span>

<span class="sd">        &gt;&gt;&gt; assert signature(f).parameters == signature(first).parameters</span>

<span class="sd">        ... and the return_annotation of the line (composition) is taken from the last</span>
<span class="sd">        function.</span>

<span class="sd">        &gt;&gt;&gt; assert signature(f).return_annotation == signature(last).return_annotation</span>

<span class="sd">        Border case: One function only</span>

<span class="sd">        &gt;&gt;&gt; same_as_first = Line(first)</span>
<span class="sd">        &gt;&gt;&gt; assert same_as_first(42) == first(42)</span>

<span class="sd">        You can also give names to: The (pipe)line, input, and output.</span>
<span class="sd">        This is useful for visualization and analysis purposes.</span>

<span class="sd">        &gt;&gt;&gt; from functools import partial</span>
<span class="sd">        &gt;&gt;&gt; pipe = Line(</span>
<span class="sd">        ...     sum, str, print,</span>
<span class="sd">        ... pipeline_name=&#39;MyPipeline&#39;, input_name=&#39;x&#39;, output_name=&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pipe</span>
<span class="sd">        MyPipeline(iterable, /, start=0)</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">named_funcs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">funcs</span><span class="p">,</span> <span class="n">named_funcs</span> <span class="o">=</span> <span class="n">_merge_funcs_and_named_funcs</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">named_funcs</span><span class="p">)</span>

        <span class="c1"># It might make sense that if no funcs are specified, we take the lined to be</span>
        <span class="c1"># the identity, but we&#39;ll implement only when needed</span>
        <span class="c1"># TODO: Refactor validation as hidden func (underscore-prefixed)</span>
        <span class="c1"># TODO: Move validation just before attr assignment (after normalize)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;You need to specify at least one function!&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">callable</span><span class="p">,</span> <span class="n">funcs</span><span class="p">))),</span> <span class="s2">&quot;Hey, some funcs not callable!&quot;</span>

        <span class="n">funcs</span><span class="p">,</span> <span class="n">named_funcs</span> <span class="o">=</span> <span class="n">_normalize_funcs_and_named_funcs</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">named_funcs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span> <span class="o">=</span> <span class="n">funcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">named_funcs</span> <span class="o">=</span> <span class="n">named_funcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_name</span> <span class="o">=</span> <span class="n">input_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_name</span> <span class="o">=</span> <span class="n">output_name</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">f</span> <span class="o">==</span> <span class="n">ff</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_funcs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;funcs and named_funcs are not aligned after merging&quot;</span>
        <span class="k">if</span> <span class="n">pipeline_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">pipeline_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">pipeline_name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">_signature_of_pipeline</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">)</span>

    <span class="c1"># Note: Did this to lighten __init__, but made signature(Line) not work</span>
    <span class="c1"># @property</span>
    <span class="c1"># def __signature__(self):</span>
    <span class="c1">#     return _signature_of_pipeline(*self.funcs)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">first_func</span><span class="p">,</span> <span class="o">*</span><span class="n">other_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">first_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">other_funcs</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a sub-pipeline through a [...] interface&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;a tuple key should have two elements only: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subline</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subline</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a sub-pipeline.</span>

<span class="sd">        A more natural interface to subline is the [...] one, that is, using</span>
<span class="sd">        ``line[k]`` instead of ``line.subline(k)`` and</span>
<span class="sd">        ``line[k, name]`` instead of ``line.subline(k, name)``.</span>

<span class="sd">        This is what we&#39;ll demo here.</span>

<span class="sd">        &gt;&gt;&gt; from lined import Line</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; def add(a, b=3):</span>
<span class="sd">        ...     return a + b</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; def mult(x, y=2):</span>
<span class="sd">        ...     return x * y</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; def exp(m, n=1):</span>
<span class="sd">        ...     return m ** n</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; f = Line(add, mult, exp, pipeline_name=&#39;line&#39;)</span>
<span class="sd">        &gt;&gt;&gt; f</span>
<span class="sd">        line(a, b=3)</span>
<span class="sd">        &gt;&gt;&gt; f(4)  # ((4 + 3) * 2) ** 1 == 7 * 2 == 14</span>
<span class="sd">        14</span>

<span class="sd">        A Line instance acts a bit like a list of the functions that compose it.</span>
<span class="sd">        That is, you can access individual elements like so</span>

<span class="sd">        &gt;&gt;&gt; just_the_mult = f[1]</span>
<span class="sd">        &gt;&gt;&gt; just_the_mult(10, 3)  # 10 * 3 == 30</span>
<span class="sd">        30</span>

<span class="sd">        Or slices like so:</span>

<span class="sd">        &gt;&gt;&gt; from_mult_onward = f[1:]</span>
<span class="sd">        &gt;&gt;&gt; from_mult_onward(4)  # (4 * 2) ** 1 == 8</span>
<span class="sd">        8</span>

<span class="sd">        Even use names in the slices:</span>

<span class="sd">        &gt;&gt;&gt; from_add_to_just_before_exp = f[&#39;add&#39;:&#39;exp&#39;]  # equivalent to f[0:2]</span>
<span class="sd">        &gt;&gt;&gt; from_add_to_just_before_exp(4)  # (4 + 3) * 2 == 14</span>
<span class="sd">        14</span>

<span class="sd">        Note what the ``repr`` of these sublines are:</span>

<span class="sd">        &gt;&gt;&gt; just_the_mult</span>
<span class="sd">        line[1](x, y=2)</span>
<span class="sd">        &gt;&gt;&gt; from_mult_onward</span>
<span class="sd">        line[1:None](x, y=2)</span>
<span class="sd">        &gt;&gt;&gt; from_add_to_just_before_exp</span>
<span class="sd">        line[add:exp](a, b=3)</span>

<span class="sd">        Indeed, the names of these objects are:</span>

<span class="sd">        &gt;&gt;&gt; just_the_mult.name</span>
<span class="sd">        &#39;line[1]&#39;</span>
<span class="sd">        &gt;&gt;&gt; from_mult_onward.name</span>
<span class="sd">        &#39;line[1:None]&#39;</span>
<span class="sd">        &gt;&gt;&gt; from_add_to_just_before_exp.name</span>
<span class="sd">        &#39;line[add:exp]&#39;</span>

<span class="sd">        Useful default, since it gives you information on what part of the original</span>
<span class="sd">        line we extracted as well as what the signature of this subline is.</span>
<span class="sd">        But sometimes you&#39;d like to give our own name to the subline, and we can,</span>
<span class="sd">        like so:</span>

<span class="sd">        &gt;&gt;&gt; just_the_mult = f[1, &#39;multiplier&#39;]</span>
<span class="sd">        &gt;&gt;&gt; just_the_mult</span>
<span class="sd">        multiplier(x, y=2)</span>
<span class="sd">        &gt;&gt;&gt; just_the_mult.name</span>
<span class="sd">        &#39;multiplier&#39;</span>

<span class="sd">        Note that the `__name__` is also assigned:</span>

<span class="sd">        &gt;&gt;&gt; just_the_mult.__name__</span>
<span class="sd">        &#39;multiplier&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="n">item_str</span> <span class="o">=</span> <span class="n">_get_item_str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">ensure_numerical_keys</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">named_funcs</span><span class="p">))</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="n">_ensure_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">item_str</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Need to get rid of the forced position only first arg</span>
                <span class="c1"># TODO: Get rid of this if/when we get rid of forced position only</span>
                <span class="n">first_fnode</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">funcs</span>
                <span class="n">underlying_funcs_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">first_fnode</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">first_fnode</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__func__&quot;</span><span class="p">):</span>
                    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">underlying_funcs_sig</span><span class="p">)</span>
                    <span class="n">funcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fnode</span><span class="p">(</span><span class="n">sig</span><span class="p">(</span><span class="n">first_fnode</span><span class="o">.</span><span class="n">func</span><span class="p">),</span> <span class="n">first_fnode</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># first_fnode.func is a method, and we get</span>
                    <span class="c1"># AttributeError: &#39;method&#39; object has no attribute &#39;__signature__&#39;</span>
                    <span class="c1"># when trying in change signature</span>
                    <span class="c1"># To reproduce, remove not hasattr(first_fnode.func, &#39;__func__&#39;)</span>
                    <span class="c1"># condition</span>
                    <span class="k">pass</span>
            <span class="n">sub_obj</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="o">*</span><span class="n">funcs</span><span class="p">,</span> <span class="n">pipeline_name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># if name is not None:</span>
            <span class="c1">#     sub_obj.name = name</span>
            <span class="c1">#     # sub_obj.__name__ = name</span>
            <span class="k">return</span> <span class="n">sub_obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to handle that type of key: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dot_digraph_body</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fnode_shape</span><span class="o">=</span><span class="s2">&quot;box&quot;</span><span class="p">,</span>
        <span class="n">vnode_shape</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
        <span class="n">input_node</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">output_node</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">edges_gen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">arg_param_to_string</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">name_with_varkind_and_default_marker</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># no functions, so just return</span>

        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">yield</span> <span class="s1">&#39;rankdir=&quot;LR&quot;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">prefix</span>

        <span class="n">func_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">named_funcs</span><span class="p">)</span>
        <span class="n">func_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">name_to_id</span><span class="p">,</span> <span class="n">func_names</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">input_node</span><span class="p">:</span>
            <span class="n">first_func_id</span> <span class="o">=</span> <span class="n">func_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">input_node</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">argname</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="n">arg_param_to_string</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">argname</span><span class="si">}</span><span class="s1"> [shape=&quot;</span><span class="si">{</span><span class="n">vnode_shape</span><span class="si">}</span><span class="s1">&quot; label=&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>
                    <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">argname</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">first_func_id</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">elif</span> <span class="n">input_node</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">input_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_name</span> <span class="ow">or</span> <span class="s2">&quot;input&quot;</span>
                <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">input_node</span><span class="si">}</span><span class="s1"> [shape=&quot;</span><span class="si">{</span><span class="n">vnode_shape</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>
                <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">input_node</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">first_func_id</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">for</span> <span class="n">func_id</span><span class="p">,</span> <span class="n">fname</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">func_ids</span><span class="p">,</span> <span class="n">func_names</span><span class="p">):</span>
            <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func_id</span><span class="si">}</span><span class="s1"> [shape=&quot;</span><span class="si">{</span><span class="n">fnode_shape</span><span class="si">}</span><span class="s1">&quot; label=&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>

        <span class="k">if</span> <span class="n">edges_gen</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edges_gen</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">from_func_id</span><span class="p">,</span> <span class="n">to_func_id</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">func_ids</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">func_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">from_func_id</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">to_func_id</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="n">edges_gen</span>

        <span class="k">if</span> <span class="n">output_node</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_name</span>
        <span class="k">if</span> <span class="n">output_node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">output_node</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">output_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_name</span> <span class="ow">or</span> <span class="s2">&quot;output&quot;</span>
            <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">output_node</span><span class="si">}</span><span class="s1"> [shape=&quot;</span><span class="si">{</span><span class="n">vnode_shape</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>
            <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_name</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">dot_digraph_body</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dot_digraph_ascii</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get an ascii art string that represents the pipeline&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">lined.util</span> <span class="kn">import</span> <span class="n">dot_to_ascii</span>

        <span class="k">return</span> <span class="n">dot_to_ascii</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dot_digraph_body</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)))</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">dot_digraph_body</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dot_digraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">graphviz</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ModuleNotFoundError</span><span class="p">,</span> <span class="ne">ImportError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="se">\n</span><span class="s2">You may not have graphviz installed. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;See https://pypi.org/project/graphviz/.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Note: Since graphviz 0.18, need to have a newline in body lines!</span>
        <span class="n">body</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_add_new_line_if_none</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot_digraph_body</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Digraph</span><span class="p">(</span><span class="n">body</span><span class="o">=</span><span class="n">body</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name_of_instance</span><span class="p">()</span><span class="si">}{</span><span class="n">Sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1"># funcs_str = &#39;, &#39;.join((fname for fname in self.named_funcs))</span>
        <span class="c1"># suffix = &#39;&#39;</span>
        <span class="c1"># if self.input_name is not None:</span>
        <span class="c1">#     suffix += f&quot;, input_name=&#39;{self.input_name}&#39;&quot;</span>
        <span class="c1"># if self.output_name is not None:</span>
        <span class="c1">#     suffix += f&quot;, output_name=&#39;{self.output_name}&#39;&quot;</span>
        <span class="c1"># return f&#39;{self._name_of_instance()}({funcs_str}{suffix})&#39;</span>

    <span class="k">def</span> <span class="nf">_name_of_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_jdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;funcs&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">,</span>
            <span class="s2">&quot;pipeline_name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s2">&quot;input_name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_name</span><span class="p">,</span>
            <span class="s2">&quot;output_name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_name</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_jdict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">jdict</span><span class="p">):</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="n">jdict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;funcs&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">,</span> <span class="o">**</span><span class="n">jdict</span><span class="p">)</span>


<span class="n">Pipeline</span> <span class="o">=</span> <span class="n">Line</span>  <span class="c1"># for back-compatibility</span>

<span class="kn">from</span> <span class="nn">i2.deco</span> <span class="kn">import</span> <span class="n">mk_call_logger</span><span class="p">,</span> <span class="n">_call_signature</span>


<div class="viewcode-block" id="log_calls"><a class="viewcode-back" href="../../module_docs/lined/base.html#lined.base.log_calls">[docs]</a><span class="k">def</span> <span class="nf">log_calls</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="n">Line</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="nb">print</span><span class="p">,</span> <span class="n">what_to_log</span><span class="o">=</span><span class="n">_call_signature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Log the calls of every step of a pipeline.</span>

<span class="sd">    :param line: A Line object</span>
<span class="sd">    :param logger: A callable that will be called on the output of what_to_log.</span>
<span class="sd">        Default is print.</span>
<span class="sd">    :param what_to_log: A callable that will be called on (func, args, kwargs) to</span>
<span class="sd">        produce the data that will be pased on to logger.</span>
<span class="sd">        By default it will produce a string representation of the call.</span>
<span class="sd">    :return: A pipeline that will log the calls made at every step</span>

<span class="sd">    &gt;&gt;&gt; from math import log2</span>
<span class="sd">    &gt;&gt;&gt; pipe = Line(sum, log2, str)</span>
<span class="sd">    &gt;&gt;&gt; logged_pipe = log_calls(pipe)</span>
<span class="sd">    &gt;&gt;&gt; t = logged_pipe([1, 3, 4])</span>
<span class="sd">    sum([1, 3, 4], )</span>
<span class="sd">    log2(8, )</span>
<span class="sd">    str(3.0, )</span>
<span class="sd">    &gt;&gt;&gt; t</span>
<span class="sd">    &#39;3.0&#39;</span>

<span class="sd">    We&#39;re using the ``(logger=print, what_to_log=_call_signature)`` default here,</span>
<span class="sd">    but other pair can be useful in some situations.</span>

<span class="sd">    For example, some of these calls may involve objects whose string representation</span>
<span class="sd">    is no informative, or two large to be useful.</span>
<span class="sd">    In this case, one could instead set ``(logger, what_to_log)`` to serialize the</span>
<span class="sd">    calls and save in a DB or pickle files that could then be studied.</span>

<span class="sd">    Note: This function logs all the calls.</span>

<span class="sd">    If you want to log only some calls, you might want to use lined.tools.side_call</span>
<span class="sd">    or ``lined.tools.print_and_pass_on``.</span>
<span class="sd">    You can also provide a custome ``(logger, what_to_log)`` pair that will do something</span>
<span class="sd">    special according to the function (namely, log the call or not).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">call_logger</span> <span class="o">=</span> <span class="n">mk_call_logger</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="n">what_to_log</span><span class="p">)</span>

    <span class="c1"># TODO: applying call_logger to _fnode didn&#39;t work. Would be good to make it work.</span>
    <span class="n">named_funcs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">call_logger</span><span class="p">(</span><span class="n">_fnode</span><span class="o">.</span><span class="n">func</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">_fnode</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">named_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">]</span>
    <span class="c1"># TODO: In the following, we would lose any other attributes we might have in the</span>
    <span class="c1">#  line instance. We&#39;d like to clone it (with transformed funcs) instead.</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">line</span><span class="p">)(</span><span class="o">*</span><span class="n">named_funcs</span><span class="p">)</span></div>


<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>


<div class="viewcode-block" id="Sentinel"><a class="viewcode-back" href="../../module_docs/lined/base.html#lined.base.Sentinel">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Sentinel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;To make sentinels holding an optional value&quot;&quot;&quot;</span>

    <span class="n">val</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">this_is_not</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">filter_in</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">sentinel_val</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">condition</span><span class="p">,</span> <span class="n">Callable</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;condition need to be callable, but was </span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">def</span> <span class="nf">filt</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">condition</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">x</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sentinel_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">filt</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">filter_out</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">sentinel_val</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">condition</span><span class="p">,</span> <span class="n">Callable</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;condition need to be callable, but was </span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">def</span> <span class="nf">filt</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">condition</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">x</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sentinel_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">filt</span></div>


<span class="k">class</span> <span class="nc">Conditions</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">excluded_val</span><span class="p">(</span><span class="n">excluded_val</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">excluded_val</span>

        <span class="k">return</span> <span class="n">condition</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">exclude_type</span><span class="p">(</span><span class="n">excluded_type</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">excluded_type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">condition</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">include_type</span><span class="p">(</span><span class="n">excluded_type</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">excluded_type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">condition</span>


<span class="c1"># ---------------------------------------------------------------------------------------</span>


<span class="k">def</span> <span class="nf">normalize_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ch_signature_to_all_pk</span><span class="p">(</span><span class="n">tuple_the_args</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">NoSuchConfig</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;no_such_config&quot;</span>


<span class="n">no_such_config</span> <span class="o">=</span> <span class="n">NoSuchConfig</span><span class="p">()</span>


<div class="viewcode-block" id="Configs"><a class="viewcode-back" href="../../module_docs/lined/base.html#lined.base.Configs">[docs]</a><span class="k">class</span> <span class="nc">Configs</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A dict, whose keys can be access as if they were attributes.</span>
<span class="sd">    Also defaults to sentinel _default when</span>

<span class="sd">    &gt;&gt;&gt; s = Configs()</span>

<span class="sd">    Write it as you do with attributes or dict keys,</span>
<span class="sd">    get it as an attribute and a dict keys.</span>

<span class="sd">    &gt;&gt;&gt; s.foo = &#39;bar&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert s.foo == &#39;bar&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;foo&#39;] == &#39;bar&#39;</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;hello&#39;] = &#39;world&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert s.hello == &#39;world&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;hello&#39;] == &#39;world&#39;</span>
<span class="sd">    &gt;&gt;&gt; hasattr(s, &#39;hello&#39;)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; s[&#39;does not exist&#39;]</span>
<span class="sd">    no_such_config</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No such attribute: &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No such attribute: &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_missing_callback</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_key_missing_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Override if needed. Can also just raise to raise KeyError&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">no_such_config</span></div>


<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">ChainMap</span>

<span class="n">dflt_configs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">fnode_shape</span><span class="o">=</span><span class="s2">&quot;box&quot;</span><span class="p">,</span>
    <span class="n">vnode_shape</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
    <span class="n">display_all_arguments</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">edge_kind</span><span class="o">=</span><span class="s2">&quot;to_args_on_edge&quot;</span><span class="p">,</span>
    <span class="n">input_node</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">output_node</span><span class="o">=</span><span class="s2">&quot;output&quot;</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="LineParametrized"><a class="viewcode-back" href="../../module_docs/lined/base.html#lined.base.LineParametrized">[docs]</a><span class="k">class</span> <span class="nc">LineParametrized</span><span class="p">(</span><span class="n">Line</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A pipeline that exposes all inputs of all the functions of the pipeline.</span>

<span class="sd">    For example, say you have two functions `f(a, b=1)` and `g(x, y=2)`.</span>

<span class="sd">    `Line(f, g)` would be a function with `a` and `b` as your inputs.</span>

<span class="sd">    .. code-block::</span>
<span class="sd">            ┌───┐     ┌───┐</span>
<span class="sd">     a  ──▶ │ f │ ──▶ │ g │ ──▶  output</span>
<span class="sd">            └───┘     └───┘</span>
<span class="sd">              ▲</span>
<span class="sd">              │</span>
<span class="sd">              │</span>

<span class="sd">              b=</span>


<span class="sd">    On the other hand, `LineParametrized(f, g)` will give you control over `y`.</span>

<span class="sd">    .. code-block::</span>
<span class="sd">            ┌───┐  x   ┌───┐</span>
<span class="sd">     a  ──▶ │ f │ ───▶ │ g │ ──▶  output</span>
<span class="sd">            └───┘      └───┘</span>
<span class="sd">              ▲          ▲</span>
<span class="sd">              │          │</span>
<span class="sd">              │          │</span>

<span class="sd">              b=         y=</span>

<span class="sd">    &gt;&gt;&gt; def add(a, b=0): return a + b</span>
<span class="sd">    &gt;&gt;&gt; def times(x, y=2): return x * y</span>
<span class="sd">    &gt;&gt;&gt; def exp(r, e=3):  return r ** e</span>
<span class="sd">    &gt;&gt;&gt; f = LineParametrized(add, times, exp)</span>
<span class="sd">    &gt;&gt;&gt; assert f(2) == 64  # as before</span>
<span class="sd">    &gt;&gt;&gt; assert f(2, 3) == 1000  # as before, but now you can do this...</span>
<span class="sd">    &gt;&gt;&gt; assert f(2, 3, y=1) == 125  # ((2 + 3) * 1) ** 3 == 125</span>
<span class="sd">    &gt;&gt;&gt; assert f(2, 3, e=1) == 10  # ((2 + 3) * 2) ** 1 == 10</span>
<span class="sd">    &gt;&gt;&gt; assert f(2, 3, y=3, e=1) == 15  # ((2 + 3) * 3) ** 1 == 15</span>
<span class="sd">    &gt;&gt;&gt; assert f(2, y=10, e=1) == 20  # (skipping b here! using default b=0) ((2 + 0) * 10) ** 1 == 20</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; signature(f)</span>
<span class="sd">    &lt;Sig (a, b=0, *, y=2, e=3)&gt;</span>

<span class="sd">    Note that `y` and `e` are keyword-only arguments.</span>
<span class="sd">    All arguments that are not from the first function will be keyword only</span>
<span class="sd">    (except for the first argument of these functions, which do not appear at all</span>
<span class="sd">    since they&#39;re used as the &quot;connecting arguments&quot;).</span>

<span class="sd">    Note in the above signature, that `x` and `r` are missing.</span>
<span class="sd">    That&#39;s because these are &quot;connecting&quot; arguments.</span>
<span class="sd">    &#39;x&#39; comes from `add` and is fed to `times`.</span>
<span class="sd">    `r` comes from `times` and is fed to `exp`.</span>

<span class="sd">    &gt;&gt;&gt; print(f.dot_digraph_ascii())</span>
<span class="sd">            ┌─────┐  x   ┌───────┐  r   ┌─────┐</span>
<span class="sd">     a  ──▶ │ add │ ───▶ │ times │ ───▶ │ exp │ ──▶  output</span>
<span class="sd">            └─────┘      └───────┘      └─────┘</span>
<span class="sd">              ▲            ▲              ▲</span>
<span class="sd">              │            │              │</span>
<span class="sd">              │            │              │</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">              b=            y=            e=</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>

<span class="sd">    &gt;&gt;&gt; print(f.dot_digraph_ascii(edge_kind=&#39;simple&#39;))</span>
<span class="sd">            ┌─────┐     ┌───────┐     ┌─────┐</span>
<span class="sd">     a  ──▶ │ add │ ──▶ │ times │ ──▶ │ exp │ ──▶  output</span>
<span class="sd">            └─────┘     └───────┘     └─────┘</span>
<span class="sd">              ▲</span>
<span class="sd">              │</span>
<span class="sd">              │</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">              b=</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>

<span class="sd">    &gt;&gt;&gt; print(f.dot_digraph_ascii(edge_kind=&#39;simple_on_edge&#39;))</span>
<span class="sd">            ┌─────┐  x   ┌───────┐  r   ┌─────┐</span>
<span class="sd">     a  ──▶ │ add │ ───▶ │ times │ ───▶ │ exp │ ──▶  output</span>
<span class="sd">            └─────┘      └───────┘      └─────┘</span>
<span class="sd">              ▲</span>
<span class="sd">              │</span>
<span class="sd">              │</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">              b=</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>

<span class="sd">    &gt;&gt;&gt; print(f.dot_digraph_ascii(edge_kind=&#39;to_args&#39;))</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">                            x            r</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">                          │             │</span>
<span class="sd">                          │             │</span>
<span class="sd">                          ▼             ▼</span>
<span class="sd">            ┌─────┐     ┌───────┐     ┌─────┐</span>
<span class="sd">     a  ──▶ │ add │ ──▶ │ times │ ──▶ │ exp │ ──▶  output</span>
<span class="sd">            └─────┘     └───────┘     └─────┘</span>
<span class="sd">              ▲           ▲             ▲</span>
<span class="sd">              │           │             │</span>
<span class="sd">              │           │             │</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">              b=           y=           e=</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@Sig</span><span class="o">.</span><span class="n">from_objs</span><span class="p">(</span>
        <span class="n">Line</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;default_conflict_method&quot;</span><span class="p">,</span> <span class="n">DFLT_DEFAULT_CONFLICT_METHOD</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">default_conflict_method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;default_conflict_method&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">first_func</span><span class="p">,</span> <span class="o">*</span><span class="n">_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span>

        <span class="k">def</span> <span class="nf">sig_without_the_first_input</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">-</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">sig</span><span class="o">.</span><span class="n">ch_kinds</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">KO</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">})</span>

        <span class="c1"># _funcs = map(normalize_func, _funcs)  # TODO: Test edge cases to assess need</span>
        <span class="n">_funcs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">sig_without_the_first_input</span><span class="p">,</span> <span class="n">_funcs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Sig</span><span class="o">.</span><span class="n">from_objs</span><span class="p">(</span>
            <span class="o">*</span><span class="p">(</span><span class="n">first_func</span><span class="p">,</span> <span class="o">*</span><span class="n">_funcs</span><span class="p">),</span>
            <span class="n">default_conflict_method</span><span class="o">=</span><span class="n">default_conflict_method</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">first_func</span><span class="p">,</span> <span class="o">*</span><span class="n">other_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">call_forgivingly</span><span class="p">(</span><span class="n">first_func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">other_funcs</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">call_forgivingly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="c1"># @property</span>
    <span class="c1"># def __signature__(self):</span>
    <span class="c1">#     return Sig.from_objs(*self.funcs)</span>

    <span class="c1"># TODO: Try merging Line.dot_diagraph_body and this, for reuse</span>
    <span class="k">def</span> <span class="nf">dot_digraph_body</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_kind</span><span class="o">=</span><span class="s2">&quot;to_args_on_edge&quot;</span><span class="p">,</span>
        <span class="n">convention</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">required_arg_line</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bound_arg_line</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">Configs</span><span class="p">(</span>
            <span class="n">ChainMap</span><span class="p">(</span>
                <span class="n">convention</span> <span class="ow">or</span> <span class="p">{},</span>
                <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">edge_kind</span><span class="o">=</span><span class="n">edge_kind</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">),</span>
                <span class="n">dflt_configs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">required_arg_line</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">required_arg_line</span><span class="p">(</span><span class="n">argname</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">argname</span><span class="si">}</span><span class="s1"> [shape=&quot;</span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">vnode_shape</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>

        <span class="k">if</span> <span class="n">bound_arg_line</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">bound_arg_line</span><span class="p">(</span><span class="n">argname</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">argname_with_equals</span> <span class="o">=</span> <span class="n">argname</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">argname</span><span class="si">}</span><span class="s1"> [shape=&quot;</span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">vnode_shape</span><span class="si">}</span><span class="s1">&quot; label=&quot;&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">argname_with_equals</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>
                <span class="p">)</span>

        <span class="k">def</span> <span class="nf">lines_for_argname</span><span class="p">(</span><span class="n">func_id</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">argname</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">argname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">defaults</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">required_arg_line</span><span class="p">(</span><span class="n">argname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># this argname is bound (has a default)</span>
                <span class="k">yield</span> <span class="n">bound_arg_line</span><span class="p">(</span><span class="n">argname</span><span class="p">)</span>
            <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">argname</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">func_id</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">yield</span> <span class="s1">&#39;rankdir=&quot;LR&quot;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">prefix</span>

        <span class="n">first_func</span><span class="p">,</span> <span class="o">*</span><span class="n">_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span>
        <span class="n">func_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">name_to_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_funcs</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">func_id</span><span class="p">,</span> <span class="n">func_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">func_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_funcs</span><span class="p">):</span>
            <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func_id</span><span class="si">}</span><span class="s1"> [shape=&quot;</span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">fnode_shape</span><span class="si">}</span><span class="s1">&quot; label=&quot;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>

        <span class="n">first_func_id</span><span class="p">,</span> <span class="o">*</span><span class="n">_func_ids</span> <span class="o">=</span> <span class="n">func_ids</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">input_node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">input_node</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">first_func</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">argname</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
                    <span class="k">yield from</span> <span class="n">lines_for_argname</span><span class="p">(</span><span class="n">first_func_id</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">argname</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">input_node</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">input_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_name</span> <span class="ow">or</span> <span class="s2">&quot;input&quot;</span>
                <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">input_node</span><span class="si">}</span><span class="s1"> [shape=&quot;</span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">vnode_shape</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>
                <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">input_node</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">first_func_id</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">input_node</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">first_func_id</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">previous_func_id</span> <span class="o">=</span> <span class="n">first_func_id</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">func_id</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">func_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_funcs</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">first_arg</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>

                <span class="n">on_edge</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">edge_kind</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;on_edge&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">on_edge</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">previous_func_id</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">func_id</span><span class="si">}</span><span class="s1"> [label=&quot;</span><span class="si">{</span><span class="n">first_arg</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">previous_func_id</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">func_id</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">edge_kind</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;to_args&quot;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">display_all_arguments</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">argname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">on_edge</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">continue</span>  <span class="c1"># skip first arg if on_edge mode</span>
                            <span class="k">yield from</span> <span class="n">lines_for_argname</span><span class="p">(</span><span class="n">func_id</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">argname</span><span class="p">)</span>

                <span class="n">previous_func_id</span> <span class="o">=</span> <span class="n">func_id</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">output_node</span><span class="p">:</span>
            <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">output_node</span><span class="si">}</span><span class="s1"> [shape=&quot;</span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">vnode_shape</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>
            <span class="k">yield</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func_id</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">output_node</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">dot_digraph_body</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dot_digraph_ascii</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get an ascii art string that represents the pipeline&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">dot_digraph_ascii</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">dot_digraph_body</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dot_digraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">dot_digraph</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># ---------------------------------------------------------------------------------------</span>


<div class="viewcode-block" id="LineSentineled"><a class="viewcode-back" href="../../module_docs/lined/base.html#lined.base.LineSentineled">[docs]</a><span class="k">class</span> <span class="nc">LineSentineled</span><span class="p">(</span><span class="n">Line</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A pipeline that can be interrupted by a sentinel.</span>

<span class="sd">    Sentinels are useful to interrupt the pipeline computation.</span>

<span class="sd">    Say, for example, you know if the length of an input iterable divided by three is</span>
<span class="sd">    1 or 2.</span>
<span class="sd">    You wouldn&#39;t want to divide by 0 or have a loop choke on an input that doesn&#39;t</span>
<span class="sd">    have a length.</span>

<span class="sd">    So you do this:</span>

<span class="sd">    &gt;&gt;&gt; pipe = LineSentineled(</span>
<span class="sd">    ...     lambda x: (hasattr(x, &#39;__len__&#39;) and x) or Sentinel(&#39;no length&#39;), # returns x if it has a length, and None if not</span>
<span class="sd">    ...     len,</span>
<span class="sd">    ...     lambda x: x % 3,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; pipe([1,2,3,4])</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; pipe(1)</span>
<span class="sd">    Sentinel(val=&#39;no length&#39;)</span>
<span class="sd">    &gt;&gt;&gt; # which allows us to do things like:</span>
<span class="sd">    &gt;&gt;&gt; list(filter(Sentinel.this_is_not, map(pipe, [[1,2,3,4], None, 1, [1,2,3]])))</span>
<span class="sd">    [1, 0]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">first_func</span><span class="p">,</span> <span class="o">*</span><span class="n">other_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">first_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">Sentinel</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">other_funcs</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">Sentinel</span><span class="p">):</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">out</span></div>


<span class="n">SentineledPipeline</span> <span class="o">=</span> <span class="n">LineSentineled</span>  <span class="c1"># back-compatibility alias</span>


<span class="k">def</span> <span class="nf">inject_names_if_missing</span><span class="p">(</span><span class="n">funcs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
        <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">func_name</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">funcs</span>


<span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">stacked_funcs</span><span class="p">(</span><span class="n">input_tuple</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_tuple</span><span class="p">),</span> <span class="p">(</span>
            <span class="s2">&quot;the length of input_tuple ({len(input_tuple)} should be the same length&quot;</span>
            <span class="s2">&quot; (len</span><span class="si">{funcs}</span><span class="s2">) as the funcs: </span><span class="si">{input_tuple}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">starmap</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">input_tuple</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">stacked_funcs</span>


<span class="c1"># TODO: Need tests and the new args of Line (named_funcs...)</span>
<span class="k">class</span> <span class="nc">LayeredPipeline</span><span class="p">(</span><span class="n">Line</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">funcs</span><span class="p">:</span> <span class="n">LayeredFuncs</span><span class="p">,</span> <span class="n">pipeline_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_funcs</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">func</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
                    <span class="k">yield</span> <span class="n">LayeredPipeline</span><span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to deal with this func: </span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">_funcs</span><span class="p">(),</span> <span class="n">pipeline_name</span><span class="o">=</span><span class="n">pipeline_name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_signature_of_pipeline</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">):</span>
    <span class="n">n_funcs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_funcs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to specify at least one function!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">n_funcs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">first_func</span> <span class="o">=</span> <span class="n">last_func</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">first_func</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">last_func</span> <span class="o">=</span> <span class="n">funcs</span>
    <span class="c1"># Finally, let&#39;s make the __call__ have a nice signature.</span>
    <span class="c1"># Argument information from first func and return annotation from last func</span>
    <span class="k">return</span> <span class="n">signature_from_first_and_last_func</span><span class="p">(</span><span class="n">first_func</span><span class="p">,</span> <span class="n">last_func</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># try:</span>
    <span class="c1">#     input_params = list(signature(first_func).parameters.values())</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         return_annotation = signature(last_func).return_annotation</span>
    <span class="c1">#     except ValueError:</span>
    <span class="c1">#         return_annotation = Signature.empty</span>
    <span class="c1">#     return Signature(input_params, return_annotation=return_annotation)</span>
    <span class="c1"># except ValueError:</span>
    <span class="c1">#     return None</span>


<span class="kn">from</span> <span class="nn">i2</span> <span class="kn">import</span> <span class="n">ParallelFuncs</span>

<span class="n">mk_multi_func</span> <span class="o">=</span> <span class="n">ParallelFuncs</span>  <span class="c1"># back-compatibility alias</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>


<span class="c1"># Class to represent a graph</span>
<div class="viewcode-block" id="Digraph"><a class="viewcode-back" href="../../module_docs/lined/base.html#lined.base.Digraph">[docs]</a><span class="k">class</span> <span class="nc">Digraph</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class is experiemental and will probably move to meshed.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_adjacent_to</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">nodes_adjacent_to</span> <span class="o">=</span> <span class="n">nodes_adjacent_to</span> <span class="ow">or</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_adjacent_to</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">,</span> <span class="n">nodes_adjacent_to</span>
        <span class="p">)</span>  <span class="c1"># adjacency list (look it up)</span>
        <span class="c1"># self.n_vertices = vertices  # No. of vertices</span>

    <span class="c1"># function to add an edge to graph</span>
    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_adjacent_to</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># A recursive function used by topologicalSort</span>

    <span class="k">def</span> <span class="nf">_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">):</span>
        <span class="c1"># Mark the current node as visited.</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Recur for all the vertices adjacent to this vertex</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_adjacent_to</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_helper</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>

                <span class="c1"># Push current vertex to stack which stores result</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="c1"># The function to do Topological Sort. It uses recursive</span>

    <span class="c1"># topologicalSortUtil()</span>
    <span class="k">def</span> <span class="nf">topological_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Mark all the vertices as not visited</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vertices</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Call the recursive helper function to store Topological</span>
        <span class="c1"># Sort starting from all vertices one by one</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_vertices</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_helper</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>

                <span class="c1"># Print contents of stack</span>
        <span class="k">return</span> <span class="n">stack</span></div>


<span class="k">def</span> <span class="nf">_add_new_line_if_none</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Since graphviz 0.18, need to have a newline in body lines.</span>
<span class="sd">    This util is there to address that, adding newlines to body lines</span>
<span class="sd">    when missing.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">s</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">s</span>


<span class="k">def</span> <span class="nf">_get_item_str</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a string equivalent of ``k`` to use in the repr&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>  <span class="c1"># TODO: Add str k handling</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">k</span><span class="o">.</span><span class="n">stop</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown key type&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_ensure_list</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">lined.base</span> <span class="kn">import</span> <span class="n">_merge_funcs_and_named_funcs</span>
    <span class="kn">import</span> <span class="nn">pytest</span>

    <span class="k">class</span> <span class="nc">my_class</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A simple class with one method&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">class</span> <span class="nc">my_other_class</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Another simple class with one method&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>

    <span class="n">first</span> <span class="o">=</span> <span class="n">my_class</span><span class="p">()</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="n">add_one</span>

    <span class="n">second</span> <span class="o">=</span> <span class="n">my_class</span><span class="p">()</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">second</span><span class="o">.</span><span class="n">add_one</span>

    <span class="n">third</span> <span class="o">=</span> <span class="n">my_other_class</span><span class="p">()</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">third</span><span class="o">.</span><span class="n">add_one</span>

    <span class="n">i</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">j</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_merge_funcs_and_named_funcs</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">named_funcs</span><span class="o">=</span><span class="p">{})[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>